// Generated by CoffeeScript 2.0.1
(function() {
  // Visitor which looks for pragma directives for skipping coverage, and marks coffeescript nodes
  // to be skipped.

  var NodeWrapper, PRAGMAS, PRAGMA_PREFIX, SkipVisitor, _;

  _ = require('lodash');

  NodeWrapper = require('./NodeWrapper');

  PRAGMA_PREFIX = '!pragma';

  PRAGMAS = [
    {
      // '!pragma coverage-skip-next', 'istanbul ignore next'

      // Mark the next node and all descendants as `skip`.
      regex: /^!pragma\s+coverage-skip-next$/,
      istanbulRegex: /^istanbul\s+ignore\s+next$/,
      fn: function(self,
    node,
    match,
    options = {}) {
        var next;
        next = self._getNext(node,
    match);
        return next.markAll('skip',
    true);
      }
    },
    {
      // '!pragma coverage-skip-block'
      regex: /^!pragma\s+coverage-skip-block$/,
      fn: function(self,
    node,
    match,
    options = {}) {
        var ifBody, ifNode, parent, ref;
        parent = node.parent;
        parent.markAll('skip',
    true);
        if (parent.type !== 'Block') {
          /* !pragma coverage-skip-block */
          throw new Error(`Pragma '${match[0]}' at ${this._toLocString(node)} is not ` + "child of a Block (how did you even do this!?)");
        }
        if (((ref = parent.parent) != null ? ref.type : void 0) === 'If') {
          ifBody = parent;
          ifNode = parent.parent;
          if (ifBody.childName === 'body') {
            return ifNode.mark('skipIf',
    true);
          } else {
            return ifNode.mark('skipElse',
    true);
          }
        }
      }
    },
    {
      // '!pragma no-coverage-next'

      // Mark the next node and all descendants as `noCoverage`.
      regex: /^!pragma\s+no-coverage-next$/,
      fn: function(self,
    node,
    match,
    options = {}) {
        var next;
        next = self._getNext(node,
    match);
        return next.markAll('noCoverage',
    true);
      }
    },
    {
      // 'istanbul ignore if'

      // Must be before an `If` statement.  Mark the `If` as `skipIf`, and mark all children in
      // the `body` as `skip`.
      istanbulRegex: /^istanbul\s+ignore\s+if$/,
      fn: function(self,
    node,
    match,
    options = {}) {
        var ifNode, ref;
        ifNode = self._getNext(node,
    match,
    'If');
        ifNode.mark('skipIf',
    true);
        return (ref = ifNode.child('body')) != null ? ref.markAll('skip',
    true) : void 0;
      }
    },
    {
      // 'istanbul ignore next'

      // Must be before an `If` statement.  Mark the `If` as `skipElse`, and mark all children in
      // the `elseBody` as `skip`.
      istanbulRegex: /^istanbul\s+ignore\s+else$/,
      fn: function(self,
    node,
    match,
    options = {}) {
        var ifNode, ref;
        ifNode = self._getNext(node,
    match,
    'If');
        ifNode.mark('skipElse',
    true);
        return (ref = ifNode.child('elseBody')) != null ? ref.markAll('skip',
    true) : void 0;
      }
    }
  ];

  module.exports = SkipVisitor = class SkipVisitor {
    constructor(fileName) {
      this.fileName = fileName;
    }

    visitComment(node) {
      var comment, found, ref, ref1;
      comment = (ref = (ref1 = node.node.comment) != null ? ref1.trim().toLowerCase() : void 0) != null ? ref : '';
      found = false;
      if (_.startsWith(comment, PRAGMA_PREFIX)) {
        return PRAGMAS.filter(function(pragma) {
          return pragma.regex != null;
        }).forEach((pragma) => {
          var match;
          if (match = comment.match(pragma.regex)) {
            return pragma.fn(this, node, match, this.options);
          }
        });
      } else if (_.startsWith(comment, 'istanbul')) {
        return PRAGMAS.filter(function(pragma) {
          return pragma.istanbulRegex != null;
        }).forEach((pragma) => {
          var match;
          if (match = comment.match(pragma.istanbulRegex)) {
            return pragma.fn(this, node, match, this.options);
          }
        });
      }
    }

    _toLocString(node) {
      return `${this.fileName} (${node.locationData.first_line + 1}:${node.locationData.first_column + 1})`;
    }

    // Get the next non-comment statement.
    _getNext(node, match, type = null) {
      var next;
      next = node.next();
      while ((next != null ? next.type : void 0) === 'Comment') {
        // Skip over any comments
        next = next.next();
      }
      if (next == null) {
        throw new Error(`Pragma '${match[0]}' at ${this._toLocString(node)} has no next statement`);
      }
      if ((type != null) && next.type !== type) {
        throw new Error(`Statement after pragma '${match[0]}' at ${this._toLocString(node)} is not of type ${type}`);
      }
      return next;
    }

  };

}).call(this);
